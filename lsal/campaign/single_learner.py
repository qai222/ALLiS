from __future__ import annotations

import logging
from typing import Union

import numpy as np

from lsal.schema import Molecule, LigandExchangeReaction, ReactionCollection
from lsal.schema.io import get_ml_unknown_y_single_ligand, get_ml_known_y_single_ligand
from lsal.tasks.tune import tune_twin_rf, RandomForestRegressor
from lsal.twinsk.estimator import TwinRegressor
from lsal.twinsk.estimator import upper_confidence_interval
from lsal.utils import unique_element_to_indices, truncate_distribution, docstring_parameter

_known_metric = ("mu", "uci", "std", "mu-top2%", "uci-top2%", "std-top2%mu", "std-top2%uci",)
_known_metric_doc = """
            `mu`: the average of pred_mu over the whole range, not very useful...
            `uci`: the average of pred_uci over the whole range, not very useful...
            `std`: the average of pred_std over the whole range
            `mu-top2%`: the average of top2%(pred_mu) over the whole range
            `uci-top2%`: the average of top2%(pred_uci) over the whole range
            `std-top2%mu`: the average of pred_std at `i`s where pred_mu[i] is one of top2%(pred_mu)
            `std-top2%uci`: the average of pred_std at `i`s where pred_uci[i] is one of top2%(pred_uci)
"""


class SingleLigandPredictions:

    def __init__(self, ligand: Molecule, amounts: list[float], prediction_values: np.ndarray):
        """
        data class for the matrix generated by twin reg of one ligand

        :param ligand:
        :param amounts: a list of conc., each correspond a row in `prediction_values[i]`
        :param prediction_values: a 2d np array, `prediction_values[i]` represents the predictions made for amounts[i]
        """
        self.prediction_values = prediction_values
        self.amounts = amounts
        self.ligand = ligand
        assert self.prediction_values.ndim == 2
        assert len(self.amounts) == self.prediction_values.shape[0]

    def overall_uncertainty(self, topfrac: float = None):
        if topfrac is None:
            v = float(np.mean(self.pred_std))
        else:
            v = float(np.mean(self.pred_std_of_mu_top(topfrac)))
        return v

    def pred_mu_top(self, topfrac=0.02):
        top = truncate_distribution(self.pred_mu, "top", topfrac)
        return top

    def pred_std_of_mu_top(self, topfrac=0.02):
        idx = truncate_distribution(self.pred_mu, "top", topfrac, True)
        return self.pred_std[idx]

    @docstring_parameter(_known_metric_doc)
    def rank_metric(self, metric) -> float:
        """
        the metric used to rank ligands
        pred_mu[i] is the mean value of all predictions made at amounts[i]
        pred_std[i] is the std of all predictions made at amounts[i]
        pred_uci[i] is the uci of all predictions made at amounts[i]

        :param metric: {0}
        :return:
        """
        assert metric in _known_metric
        if metric == "mu":
            v = float(np.mean(self.pred_mu))
        elif metric == "uci":
            v = float(np.mean(self.pred_uci))
        elif metric == "std":
            v = float(np.mean(self.pred_uci))
        elif metric == "mu-top2%":
            v = float(np.mean(truncate_distribution(self.pred_mu, "top", 0.02, False)))
        elif metric == "uci-top2%":
            v = float(np.mean(truncate_distribution(self.pred_uci, "top", 0.02, False)))
        elif metric == "std-top2%mu":
            idx = truncate_distribution(self.pred_mu, "top", 0.02, True)
            v = float(np.mean(self.pred_std[idx]))
        elif metric == "std-top2%uci":
            idx = truncate_distribution(self.pred_uci, "top", 0.02, True)
            v = float(np.mean(self.pred_std[idx]))
        else:
            raise NotImplementedError("metric not implemented: {}".format(metric))
        return v

    @staticmethod
    def rank_ligands(ligand_predictions: list[SingleLigandPredictions], metric: list[str] = _known_metric, ) -> dict[
        str, list]:
        """
        given a metric and a range of ligand amount
        1. use `SingleLigandLearner.predict` to get predictions
        2. (use this function to) rank the (unknown) ligands for experiment priorities

        :param metric: see the docstring of SingleLigandPredictions.rank_metric, higher -> better
        :return: rank_results[metric] -> a sorted list of (ligand, value)
        """
        data = dict()
        for m in metric:
            ranking = [(lp.ligand, lp.rank_metric(m)) for lp in ligand_predictions]
            ranking = sorted(ranking, key=lambda x: x[1], reverse=True)
            data[m] = ranking
        return data

    @property
    def pred_mu(self) -> np.ndarray:
        return self.prediction_values.mean(axis=1)

    @property
    def pred_std(self) -> np.ndarray:
        return self.prediction_values.std(axis=1)

    @property
    def pred_uci(self) -> np.ndarray:
        return np.apply_along_axis(upper_confidence_interval, 1, self.prediction_values)

    @staticmethod
    def from_stacked_predictions(
            stacked_predictions: np.ndarray, ligand_col: list[Molecule],
            ligand_to_amounts: dict[Molecule, list[float]]
    ) -> list[SingleLigandPredictions]:
        """
        parse predictions (as a 2d array) given by twin estimator

        :param stacked_predictions: 2d array, size of ((num_ligands x num_amounts) x ensemble)
        :param ligand_col: a list of non-unique ligands, size of (num_ligands x num_amounts)
        :param ligand_to_amounts:
        :return:
        """
        ligand_to_indices = unique_element_to_indices(ligand_col)
        ligand_learner_predictions = []
        for ligand, indices in ligand_to_indices.items():
            llp = SingleLigandPredictions(ligand, ligand_to_amounts[ligand], stacked_predictions[indices])
            ligand_learner_predictions.append(llp)
        return ligand_learner_predictions


class SingleLigandLearner:

    def __init__(
            self,
            learned_reactions: list[LigandExchangeReaction],
            regressor: TwinRegressor,
            fom_def: str,
            ligand_to_des_record: dict[Molecule, dict]
    ):
        self.fom_def = fom_def
        self.ligand_to_des_record = ligand_to_des_record
        self.regressor = regressor
        self.learned_reactions = learned_reactions

    @property
    def learned_amount_range(self):
        return self.learned_reaction_collection.ligand_amount_range

    @property
    def learned_ligands(self):
        ligands = []
        for r in self.learned_reactions:
            for sol in r.ligands:
                if sol not in ligands:
                    ligands.append(sol)
        return ligands

    @property
    def learned_reaction_collection(self):
        return ReactionCollection(self.learned_reactions)

    @property
    def status(self):
        s = self.__class__.__name__
        s += "\nlearned ligands: {}".format(len(self.learned_ligands))
        for lig in self.learned_ligands:
            s += "\n\t {}".format(lig)
        s += "\nlearned reactions: {}".format(len(self.learned_reactions))
        return s

    def predict(
            self, ligands: list[Molecule], amounts: Union[list[float], np.ndarray], ligand_to_des_record=None
    ) -> list[SingleLigandPredictions]:
        assert len(self.learned_ligands) > 0
        # learned_amin, learned_amax, _ = self.learned_amount_range
        # assert min(amounts) >= learned_amin - 1e-5
        # assert max(amounts) <= learned_amax + 1e-5
        ligand_to_amounts = dict()
        for ligand in ligands:
            ligand_to_amounts[ligand] = amounts
        if ligand_to_des_record is None:
            ligand_to_des_record = self.ligand_to_des_record
        ligand_col, df_x, _ = get_ml_unknown_y_single_ligand(ligand_to_amounts, ligand_to_des_record)
        stacked_predictions = self.regressor.twin_predict_distribution(df_x.values)
        llps = SingleLigandPredictions.from_stacked_predictions(stacked_predictions, ligand_col,
                                                                ligand_to_amounts)
        return llps

    def teach(self, reactions: list[LigandExchangeReaction], tune=False):
        reaction_collection_to_teach = ReactionCollection(reactions)
        assert all(len(lc) == 1 for lc in reaction_collection_to_teach.unique_lcombs)
        ligand_to_reactions = {k[0]: v for k, v in
                               reaction_collection_to_teach.get_lcomb_to_reactions(limit_to=None).items()}
        ligand_col, df_x, df_y = get_ml_known_y_single_ligand(ligand_to_reactions, self.ligand_to_des_record,
                                                              self.fom_def, fill_nan=True)
        logging.warning("teaching df generated: {}".format(df_x.shape))
        if tune:
            X_train, y_train, X_test, y_test, opt = tune_twin_rf(df_x, df_y)
            reg = TwinRegressor(RandomForestRegressor(n_estimators=100, random_state=42))
            reg.set_params(**opt.best_params_)
            self.regressor = reg
        self.regressor.fit(df_x.values, df_y.values)
        self.learned_reactions = reactions

    def eval_pred_wrt_real(self, real_reactions: list[LigandExchangeReaction]) -> dict[Molecule, float]:
        reaction_collection = ReactionCollection(real_reactions)
        ligand_to_untaught_reactions = reaction_collection.get_lcomb_to_reactions(limit_to=None)
        ligand_to_mae = dict()
        for lc, reactions in ligand_to_untaught_reactions.items():
            assert len(lc) == 1  # only works for single ligand
            assert all(self.fom_def in r.properties for r in reactions)
            ligand = lc[0]
            amounts = [r.ligand_solutions[0].amount for r in reactions]
            foms = [r.properties[self.fom_def] for r in reactions]
            foms = np.nan_to_num(np.array(foms))
            sllp = self.predict([ligand, ], amounts)[0]
            mae = float(np.mean(np.abs(sllp.pred_mu - foms)))
            ligand_to_mae[ligand] = mae
        return ligand_to_mae

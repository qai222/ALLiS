from __future__ import annotations

import itertools
import logging
import random
from typing import Callable

import numpy as np
from scipy.interpolate import CubicSpline

from lsal.campaign import ReactionCollection
from lsal.schema import Molecule, LigandExchangeReaction
from lsal.schema.io import get_ml_unknown_y_single_ligand, get_ml_known_y_single_ligand
from lsal.twinsk.estimator import TwinRegressor
from lsal.twinsk.estimator import upper_confidence_interval
from lsal.utils import truncate_distribution, unique_element_to_indices


class SingleLigandPredictions:
    def __init__(self, ligand: Molecule, amounts: list[float], prediction_values: np.ndarray):
        """
        data class for the matrix generated by twin reg

        :param ligand:
        :param amounts:
        :param prediction_values:
        """
        self.prediction_values = prediction_values
        self.amounts = amounts
        self.ligand = ligand
        assert self.prediction_values.ndim == 2
        assert len(self.amounts) == self.prediction_values.shape[0]

    @property
    def pred_mu(self) -> np.ndarray:
        return self.prediction_values.mean(axis=1)

    @property
    def pred_std(self) -> np.ndarray:
        return self.prediction_values.std(axis=1)

    @property
    def pred_uci(self) -> np.ndarray:
        return np.apply_along_axis(upper_confidence_interval, 1, self.prediction_values)

    @staticmethod
    def from_stacked_predictions(stacked_predictions: np.ndarray, ligand_col: list[Molecule],
                                 ligand_to_amounts: dict[Molecule, list[float]]) -> list[
        SingleLigandPredictions]:
        ligand_to_indices = unique_element_to_indices(ligand_col)
        ligand_learner_predictions = []
        for ligand, indices in ligand_to_indices.items():
            llp = SingleLigandPredictions(ligand, ligand_to_amounts[ligand], stacked_predictions[indices])
            ligand_learner_predictions.append(llp)
        return ligand_learner_predictions

    def mc_better_than(self, other: SingleLigandPredictions, field="pred_mu", rounds=500, truncate_ratio=0.1,
                       seed=42):
        assert self.ligand.mol_type == other.ligand.mol_type
        assert self.ligand.identifier != other.ligand.identifier
        dist1 = truncate_distribution(getattr(self, field), "top", truncate_ratio)
        dist2 = truncate_distribution(getattr(other, field), "top", truncate_ratio)
        joint_populations = list(itertools.product(range(len(dist1)), range(len(dist2))))
        random.seed(seed)  # TODO hardcode?
        if rounds % 2 == 0:
            rounds += 1
        joint_samples = random.choices(joint_populations, k=rounds)
        self_better = 0
        other_better = 0
        for i, j in joint_samples:
            if dist1[i] >= dist2[j]:
                self_better += 1
            else:
                other_better += 1
        return self_better > other_better


class SingleLigandSuggestor:
    def __init__(self, ligand_to_predictions: dict[Molecule, SingleLigandPredictions], k=1):
        self.ligand_to_predictions = ligand_to_predictions
        self.ligands = sorted(self.ligand_to_predictions.keys())
        self.k = k

    def suggest_by_large_average_std(self, truncate_ratio=1.0):
        average_std_for_ligand = lambda x: np.mean(
            truncate_distribution(self.ligand_to_predictions[x].pred_std, "top", truncate_ratio))
        sorted_ligands = sorted(self.ligands, key=average_std_for_ligand, reverse=True)
        return sorted_ligands[:self.k]

    def suggest_by_large_average_mu(self, truncate_ratio=0.1):
        average_mu_for_ligand = lambda x: np.mean(
            truncate_distribution(self.ligand_to_predictions[x].pred_mu, "top", truncate_ratio))
        sorted_ligands = sorted(self.ligands, key=average_mu_for_ligand, reverse=True)
        return sorted_ligands[:self.k]

    def suggest_by_large_slope(self, npts_in_cs=500):
        # cubic spline fit mu
        def cs_slope(ligand: Molecule):
            predictions = self.ligand_to_predictions[ligand]
            cs = CubicSpline(predictions.amounts, predictions.pred_mu, bc_type="not-a-knot")
            xmax = max(predictions.amounts)
            xmin = min(predictions.amounts)
            cs_amounts = np.linspace(xmin, xmax, npts_in_cs)
            cs_values = cs(cs_amounts)
            imax = np.argmax(cs_values)
            return cs_values[imax] / cs_amounts[imax]

        sorted_ligands = sorted(self.ligands, key=cs_slope, reverse=True)
        return sorted_ligands[:self.k]

    def suggest_by_large_average_lc_of_mu_and_std(self, a=1, b=1, truncate_ratio=0.5):
        def lc_of_mu_and_std(ligand: Molecule):
            predictions = self.ligand_to_predictions[ligand]
            return np.mean(
                truncate_distribution(a * predictions.pred_mu + b * predictions.pred_std, "top", truncate_ratio))

        sorted_ligands = sorted(self.ligands, key=lc_of_mu_and_std, reverse=True)
        return sorted_ligands[:self.k]

    def suggest_by_mc(self, field: str, truncate_ratio=0.1, mc_rounds=500):

        def l1_better_than_l2(l1: Molecule, l2: Molecule):
            return self.ligand_to_predictions[l1].mc_better_than(self.ligand_to_predictions[l2], field, mc_rounds,
                                                                 truncate_ratio, 42)

        nligands = len(self.ligands)
        compare_mat = np.zeros((nligands, nligands), dtype=bool)
        for i in range(nligands):
            for j in range(i + 1, nligands):
                compare_mat[i][j] = l1_better_than_l2(self.ligands[i], self.ligands[j])
                compare_mat[j][i] = not compare_mat[i][j]

        def best_mc_ligand_index(available_indices: list[int]):
            best = available_indices[0]
            for i in available_indices[1:]:
                if compare_mat[i][best]:
                    best = i
            return best

        suggestion_list = []
        current_indices = list(range(nligands))
        while len(suggestion_list) < self.k and len(current_indices) > 0:
            best_index = best_mc_ligand_index(current_indices)
            suggestion_list.append(self.ligands[best_index])
            current_indices.remove(best_index)
        return suggestion_list


class SingleLigandLearner:

    def __init__(
            self, learned_ligands: list[Molecule], learned_reactions: list[LigandExchangeReaction],
            regressor: TwinRegressor, get_fom_field: Callable, ligand_to_des_record: dict[Molecule, dict]
    ):
        self.ligand_to_des_record = ligand_to_des_record
        self.get_fom_field = get_fom_field
        self.regressor = regressor
        self.learned_ligands = learned_ligands
        self.learned_reactions = learned_reactions

    @property
    def status(self):
        s = self.__class__.__name__
        s += "\nlearned ligands: {}".format(len(self.learned_ligands))
        for lig in self.learned_ligands:
            s += "\n\t {}".format(lig)
        s += "\nlearned reactions: {}".format(len(self.learned_reactions))
        return s

    def predict(
            self, ligands: list[Molecule], amounts: list[float], ligand_to_des_record=None
    ) -> list[SingleLigandPredictions]:
        ligand_to_amounts = dict()
        for ligand in ligands:
            ligand_to_amounts[ligand] = amounts
        if ligand_to_des_record is None:
            ligand_to_des_record = self.ligand_to_des_record
        ligand_col, df_x, _ = get_ml_unknown_y_single_ligand(ligand_to_amounts, ligand_to_des_record)
        stacked_predictions = self.regressor.twin_predict_distribution(df_x.values)
        llps = SingleLigandPredictions.from_stacked_predictions(stacked_predictions, ligand_col,
                                                                ligand_to_amounts)
        return llps

    def teach(self, reactions: ReactionCollection,
              # TODO add tune
              ):
        assert all(len(lc) == 1 for lc in reactions.unique_lcombs)
        ligand_to_reactions = {k[0]: v for k, v in reactions.get_lcomb_to_reactions(limit_to=None).items()}
        ligand_col, df_x, df_y = get_ml_known_y_single_ligand(ligand_to_reactions, self.ligand_to_des_record,
                                                              self.get_fom_field, fill_nan=True)

        self.regressor.fit(df_x.values, df_y.values)
        self.learned_ligands = [lc[0] for lc in reactions.unique_lcombs]
        self.learned_reactions = reactions.real_reactions

    def eval_pred_uncertainty(self, untaught_ligands: list[Molecule], amounts: list[float]) -> dict[Molecule, float]:
        sllps = self.predict(untaught_ligands, amounts)
        ligand_to_uncertainty = dict()
        for sllp in sllps:
            ligand_to_uncertainty[sllp.ligand] = float(np.mean(sllp.pred_std))
        return ligand_to_uncertainty

    def eval_pred_wrt_real(self, untaught_reactions: ReactionCollection):
        ligand_to_untaught_reactions = untaught_reactions.get_lcomb_to_reactions(limit_to=None)
        ligand_to_mae = dict()
        for lc, reactions in ligand_to_untaught_reactions.items():
            assert len(lc) == 1
            ligand = lc[0]
            amounts = [r.ligand_solutions[0].amount for r in reactions]
            foms = [r.properties[self.get_fom_field(r.properties.keys())] for r in reactions]
            foms = np.nan_to_num(np.array(foms))
            sllp = self.predict([ligand, ], amounts)[0]
            mae = np.mean(np.abs(sllp.pred_mu - foms))
            ligand_to_mae[ligand] = mae
        return ligand_to_mae

    def suggest_ligand(
            self, ligand_pool: list[Molecule], n_amounts: int, amount_min: float, amount_max: float,
            suggest_method: str, k: int = 1, **kwargs,
    ) -> list[Molecule]:
        amounts = np.linspace(amount_min, amount_max, n_amounts)
        sllps = self.predict(ligand_pool, amounts)
        ligand_to_predictions = {llp.ligand: llp for llp in sllps}
        suggestor = SingleLigandSuggestor(ligand_to_predictions, k)
        suggestor_func_name = "suggest_by_{}".format(suggest_method)
        suggested_ligands = suggestor.__getattribute__(suggestor_func_name)(**kwargs)
        logging.warning("SUGGEST LIGANDS: {}".format(suggested_ligands))
        return suggested_ligands
